1.什么是断言，使用场景
断言是java1.4新特性，对参数进行判断,主要用在测试阶段和开发阶段,默认是关闭的，可以使用-ea启用，-ed禁用;语法如下:
assert <布尔表达式>
assert <布尔表达式>:<错误信息>
如果布尔表达式为，程序继续执行，如果布尔表达式为假，抛出AssertionError错误，程序结束运行。

2.实参和形参
形参指的就是方法的参数列表。
实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 
形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。
形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回
实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
 
3.什么是可变参数
参数的个数是不固定的(Object ... obj),其实这就是java的语法糖，在后期处理的时候是按照数值处理的。
(1)一个方法只能有一个可变参数，并且只能是最后一个形参。
(2)因为底层是按数组处理，所以以下这种并不是重载，会编译报错。
public void a(String [] args){}
public void a(String ... args){}
(3)主函数调用形参是可变函数时，可以传入一个类型一致的数组;也可以传入多个类型一致的实参;也可以不传;
如果存在这样的两个重载的方法，在不传参数的情况下，调用的是没有参数的函数。
public void a(){}
public void a(String ... args){}

4.什么是跨域请求，跨域请求有哪些解决方法
在 HTML 中，<a/>, <form/>, <img/>, <script/>, <iframe/>, <link/> 等标签以及 Ajax 都可以指向一个资源地址，
而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。
这里的域指的是这样的一个概念：我们认为协议 + 域名 + 端口号相同，那么就是同域。
浏览器的同源策略，会对跨域请求做限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动CSRF攻击。
解决方法：
1>jsonp
JSONP 本质上是利用 <script/><img/><iframe/> 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。
JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。
JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段Javascript代码中调用了约定好的回调函数，
并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了
JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求

2>nodejs代理
3>nginx代理
4>cors(跨域资源共享)
是W3C标准，它新增的一组HTTP头字段，允许服务端其声明哪些源站有权限访问哪些资源。
CORS分为简单请求和复杂请求，处理方法也是有不同的，所以我们分别总结:

同时满足以下两个条件，就是简单请求：
请求方式是下列之一：
HEAD
GET
POST
HTTP的头信息不超出以下几种字段：
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
实现方法非常简单，只需要把服务器的响应报文里的Access-Control-Allow-Origin设置为*或者包含由 Origin指明的站点。

复杂请求
如果不是简单请求，那就是复杂请求，比如请求的方法是PUT或者DELETE，
比如Content-Type字段的类型是application/json，比如设置了自定义头信息。
复杂请求就是比简单请求多了个预检请求（preflight）而已。
预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。
只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。
除了Origin字段，还有两个字段非常重要：Access-Control-Request-Method和Access-Control-Request-Headers，
分别表示允许的请求方法和请求头。

举一个具体的例子：
现在，我们有一个页面向服务器发送了一个POST请求，并且我们自己定义了一个请求头字段My-HEADER，
这时候浏览器就会首先发送一个OPTION请求来做预检请求，请求头里有以下字段：

Access-Control-Request-Method: POST
Access-Control-Request-Headers: My-HEADER
如果预检请求成功的话，响应头里的内容如下：

Access-Control-Allow-Origin: http://example.com //表明服务器允许http://example.com的请求
Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法
Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表
Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久

5.常见的sql查询优化
1> 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
2> 很多时候用 exists 代替 in 是一个好的选择
3> 当索引列有大量数据重复时，SQL查询可能不会去利用索引,创建索引一定要选离散性好的列。
4> 索引并不是越多越好，索引可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update
时有可能会重建索引。一个表的索引数最好不要超过6个，太多则应考虑一些不常使用到的列上建的索引是否有必要。
5> 提高GROUP BY 语句的效率，可以通过将不需要的记录在GROUP BY 之前过滤掉

6.什么情况下索引会失效，会导致扫描全表
1> a表的name字段有索引，如果使用like '%张三'会导致索引失效，如果like '张三%'则不会;
2> a表的name字段有索引，where name!='张三'或者name<>'张三'会导致索引失效;
3> a表的name字段有索引，where name='张三' or name='李四'会导致索引失效;where name in('张三','李四')会导致索引失效
但是把or改成union all 索引就不会失效
4> in和not in也会导致索引失效
5> a表的age字段有索引，where age/20=100会导致索引失效，where age=100*20则不会，
所以不要在where子句对字段进行表达式操作
6> a表name有索引，where concat(name,'12')='sdd12' 会导致索引失效。
7> 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
8> a表sex有索引，但是sex的值大部分都是0，where sex='0'就会导致索引失效，创建索引一定要选离散性好的列。
9> a表age字段有索引，where age>1 会导致索引失效，但是如果where age>1 and age<10则会使用索引。 

7.乐观锁和悲观锁的理解以及使用场景
乐观锁总是假设最好的情况，每次拿数据的时候总认为别人不会修改，所以不会上锁，但是在更新的时候会判断在此
期间有没有被别人修改过；可以通过数据库加版本号或者cas实现乐观锁。乐观锁主要用在多读的场景

悲观锁总是假设最坏的情况，每次拿数据的时候都会上锁，别的线程只能阻塞直到它拿到锁（共享资源每次只给一个
线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。关系型数据库的表锁 行锁 读锁 写锁都是在操作前先
上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。悲观锁主要用在多写的场景。

8.自旋锁
Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换
到核心态中，因为状态装换需要耗费很多的处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还要长。
虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和恢复现场并不值得。如果物理
机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，
看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。

是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，
直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。

锁的本质就是线程等待，可以分为线程阻塞和线程自旋:
阻塞：要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源。
如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间， 如果对于那些需要同步的简单的代码块，获取锁
挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。

自旋：如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换
，只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。
（线程还是Runnable的，只是在执行空代码。当然一直自旋也会白白消耗计算资源。）

自旋锁存在的问题
    如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。
    上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。
自旋锁的优点
    自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是运行的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
    非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 
（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）

9.java的锁
公平锁和非公平锁
乐观锁和悲观锁
轻量级锁 重量级锁 偏向锁
自旋锁
锁粗化 锁消除
类锁和对象锁 
可重入锁
共享锁和排它锁
共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据
互斥锁:指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。
读写锁:一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。

10.内核态和用户态
内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。
用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。
系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。

因为操作系统的很多操作会消耗系统的物理资源，例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息等，
这些操作显然不能随便让任何程序都可以做，于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这
样可以做到集中管理，减少有限资源的访问和使用冲突。Intel的X86架构的CPU提供了0到3四个特权级，而在我们Linux操作系统中则主要采用了0和3
两个特权级，也就是我们通常所说的内核态和用户态。

运行于用户态的进程可以执行的操作和访问的资源都受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上也没有限制。很多程序
开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。
这里再明确一个概念，每个进程都有一个4G大小的虚拟地址空间，在这个4G大小的虚拟地址空间中，前0～3G为用户空间，每个进程的用户空间之间是相互独立的，互不相干。
而3G～4G为内核空间，内核空间中大部分区域对于所有的进程来说都是共享的，这不共享的小部分区域是存储所有进程内核栈的区域，为什么这么说，因为每个进程都存在
一个内核栈，而各个进程的内核栈之间一定是不共享的。

11.ThreadLocal
为变量在每个线程中都创建了一个副本

12.spring项目打包
mvn clean package spring-boot:repackage -DskipTests

13.线程有几种状态
java中，线程的状态使用一个枚举类型来描述的。这个枚举一共有6个值
NEW:新建;RUNNABLE:运行;BLOCKED:阻塞;WAITING:等待;TIMED_WAITING:定时等待;TERMINATED:结束

14.java内存模型

15.java内存结构

16.redis的持久化方式有哪些

17.springboot的启动过程介绍一下

18.如何进入docker
docker exec -it  58af372dbc7c  /bin/bash

19.redis数据类型
字符串(String) 哈希(Hash) 列表(List) 无序集合(Set) 有序集合(ZSet)

20.java类加载模型
避免一个类被加载多次；关键的类只能由启动类加载器去加载，为了安全考虑
其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，
发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

21.类加载过程
加载 

验证

准备:	正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），
，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
public static int value=123;
那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，
所以把value赋值为123的动作将在初始化阶段才会执行。至于“特殊情况”是指：public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶段
初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0 

解析

初始化:	初始化阶段是执行类构造器<clinit>()方法的过程,<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，
编译器收集的顺序是由语句在源文件中出现的顺序所决定的。<clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<init>()方法执行之前，父类的<clinit>()方法方法已经执行完毕。
由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。
接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，
父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。
如果在一个类的<clinit>()方法中有好事很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。

使用 卸载

