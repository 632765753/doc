## 知识型

### 什么是断言，使用场景

断言是java1.4新特性，对参数进行判断,主要用在测试阶段和开发阶段,默认是关闭的，可以使用`-ea启用`，`-da禁用`;语法如下:
assert <布尔表达式>
assert <布尔表达式>:<错误信息>
如果布尔表达式为，程序继续执行，如果布尔表达式为假，抛出AssertionError错误，程序结束运行。

### 实参和形参

形参指的就是方法的参数列表。
实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 
形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。
形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回
实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

### 什么是可变参数

参数的个数是不固定的(Object ... obj),其实这就是java的语法糖，在后期处理的时候是按照数组处理的。
(1)一个方法只能有一个可变参数，并且只能是最后一个形参。
(2)因为底层是按数组处理，所以以下这种并不是重载，会编译报错。

```java
public void a(String [] args){}
public void a(String ... args){}
```

(3)主函数调用形参是可变函数时，可以传入一个类型一致的数组;也可以传入多个类型一致的实参;也可以不传;
如果存在这样的两个重载的方法，在不传参数的情况下，调用的是没有参数的函数。

```java
public void a(){}
public void a(String ... args){}
```



### 什么是跨域请求，跨域请求有哪些解决方法

在 HTML 中，`<a/>, <form/>, <img/>, <script/>, <iframe/>, <link/>` 等标签以及 Ajax 都可以指向一个资源地址，
而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。
这里的域指的是这样的一个概念：我们认为协议 + 域名 + 端口号相同，那么就是同域。
浏览器的同源策略，会对跨域请求做限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动CSRF攻击。
解决方法：
1>jsonp
JSONP 本质上是利用 `<script/><img/><iframe/>` 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。
JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。
JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段Javascript代码中调用了约定好的回调函数，
并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了
JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求

2>nodejs代理
3>nginx代理
4>cors(跨域资源共享)
是W3C标准，它新增的一组HTTP头字段，允许服务端其声明哪些源站有权限访问哪些资源。
CORS分为简单请求和复杂请求，处理方法也是有不同的，所以我们分别总结:

同时满足以下两个条件，就是简单请求：
请求方式是下列之一：
HEAD
GET
POST
HTTP的头信息不超出以下几种字段：
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
实现方法非常简单，只需要把服务器的响应报文里的Access-Control-Allow-Origin设置为*或者包含由 Origin指明的站点。

复杂请求
如果不是简单请求，那就是复杂请求，比如请求的方法是PUT或者DELETE，
比如Content-Type字段的类型是application/json，比如设置了自定义头信息。
复杂请求就是比简单请求多了个预检请求（preflight）而已。
预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。
只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。
除了Origin字段，还有两个字段非常重要：Access-Control-Request-Method和Access-Control-Request-Headers，
分别表示允许的请求方法和请求头。

举一个具体的例子：
现在，我们有一个页面向服务器发送了一个POST请求，并且我们自己定义了一个请求头字段My-HEADER，
这时候浏览器就会首先发送一个OPTION请求来做预检请求，请求头里有以下字段：

Access-Control-Request-Method: POST
Access-Control-Request-Headers: My-HEADER
如果预检请求成功的话，响应头里的内容如下：

Access-Control-Allow-Origin: http://example.com //表明服务器允许http://example.com的请求
Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法
Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表
Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久

### 常见的sql查询优化

1> 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
2> 很多时候用 exists 代替 in 是一个好的选择
3> 当索引列有大量数据重复时，SQL查询可能不会去利用索引,创建索引一定要选离散性好的列。
4> 索引并不是越多越好，索引可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update
时有可能会重建索引。一个表的索引数最好不要超过6个，太多则应考虑一些不常使用到的列上建的索引是否有必要。
5> 提高GROUP BY 语句的效率，可以通过将不需要的记录在GROUP BY 之前过滤掉

### 什么情况下索引会失效，会导致扫描全表

1> a表的name字段有索引，如果使用like '%张三'会导致索引失效，如果like '张三%'则不会;
2> a表的name字段有索引，where name!='张三'或者name<>'张三'会导致索引失效;
3> a表的name字段有索引，age字段没有索引，where name='张三' or age=10 会导致索引失效;如果两个字段都有索引则不会失效；把or改成union all 索引就不会失效

4> not in也会导致索引失效
5> a表的age字段有索引，where age/20=100会导致索引失效，where age=100*20则不会，
所以不要在where子句对字段进行表达式操作
6> a表name有索引，where concat(name,'12')='sdd12' 会导致索引失效。
7> 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
8> a表sex有索引，但是sex的值大部分都是0，where sex='0'就会导致索引失效，创建索引一定要选离散性好的列。
9> a表age字段有索引，where age>1 会导致索引失效，但是如果where age>1 and age<10则会使用索引。 

### 乐观锁和悲观锁的理解以及使用场景

​	乐观锁总是假设最好的情况，每次拿数据的时候总认为别人不会修改，所以不会上锁，但是在更新的时候会判断在此期间有没有被别人修改过；可以通过数据库加版本号或者cas实现乐观锁。乐观锁主要用在多读的场景。

​	悲观锁总是假设最坏的情况，每次拿数据的时候都会上锁，别的线程只能阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。关系型数据库的表锁 行锁 读锁 写锁都是在操作前先
上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。悲观锁主要用在多写的场景。

### 自旋锁

​	Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换
到核心态中，因为状态装换需要耗费很多的处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还要长。
虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和恢复现场并不值得。如果物理
机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，
看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。

是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，
直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。

锁的本质就是线程等待，可以分为线程阻塞和线程自旋:
阻塞：要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源。
如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间， 如果对于那些需要同步的简单的代码块，获取锁
挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。

自旋：如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换，只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。（线程还是Runnable的，只是在执行空代码。当然一直自旋也会白白消耗计算资源。）

自旋锁存在的问题:

​	如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。
​	上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。

自旋锁的优点:

​	自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是运行的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

​	非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。(线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能)

### java的锁

公平锁和非公平锁
乐观锁和悲观锁
轻量级锁 重量级锁 偏向锁
自旋锁
锁粗化 锁消除
类锁和对象锁 
可重入锁
共享锁和排它锁
共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。
排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据
互斥锁:指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。
读写锁:一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。

### 内核态和用户态

内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。
用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。
系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。

因为操作系统的很多操作会消耗系统的物理资源，例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息等，
这些操作显然不能随便让任何程序都可以做，于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这
样可以做到集中管理，减少有限资源的访问和使用冲突。Intel的X86架构的CPU提供了0到3四个特权级，而在我们Linux操作系统中则主要采用了0和3
两个特权级，也就是我们通常所说的内核态和用户态。

运行于用户态的进程可以执行的操作和访问的资源都受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上也没有限制。很多程序
开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。
这里再明确一个概念，每个进程都有一个4G大小的虚拟地址空间，在这个4G大小的虚拟地址空间中，前0～3G为用户空间，每个进程的用户空间之间是相互独立的，互不相干。
而3G～4G为内核空间，内核空间中大部分区域对于所有的进程来说都是共享的，这不共享的小部分区域是存储所有进程内核栈的区域，为什么这么说，因为每个进程都存在
一个内核栈，而各个进程的内核栈之间一定是不共享的。

### ThreadLocal

为变量在每个线程中都创建了一个副本

### spring项目打包

> mvn clean package spring-boot:repackage -DskipTests

### 线程有几种状态

java中，线程的状态使用一个枚举类型来描述的。这个枚举一共有6个值
新建(NEW);就绪(RUNNABLE)

阻塞(BLOCKED):阻塞表示线程在等待Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。

等待(WAITING):表示正在等待其他线程采取某些操作

计时等待(TIMED_WAITING)

终止(TERMINATED)

### java内存模型

​	为了屏蔽操作系统的差异，解决并发编程的原子性 可见性 有序性的问题，抽象出来了java内存模型，他其实和jvm一样，也是一个规范。共享变量存放在主内存，每个线程都有自己的工作内存，工作内存会缓存和自己相关的变量副本，当两个线程同时访问一个共享变量的时候就会存在以上说的并发编程的问题。

#### CPU和缓存一致性

​	我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。

​	刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。

​	所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。

那么，程序的执行过程就变成了：

​	当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

​	而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。

按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。

这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。

那么，在有了多级缓存之后，程序的执行就变成了：

​	当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。

单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。

![img](https://img-blog.csdn.net/20180706172557116?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTY0MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。

* 单线程、cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。
* 单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。
* 多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。

在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

![img](https://img-blog.csdn.net/20180706185956933?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTY0MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 处理器优化和指令重排

​	上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。

​	除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。

​	可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。

#### 并发编程的问题

​	前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性，可见性和有序性问题。

​	其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。

​	我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：

原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

有序性即程序执行的顺序按照代码的先后顺序执行。

​	有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。

#### 什么是内存模型

​	前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？

​	最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。

​	所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。

​	为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

​	内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。

#### 什么是Java内存模型

​	前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。

​	我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

​	提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型。

​	Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。

![img](https://img-blog.csdn.net/20180709193649114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTY0MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



​	JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

​	在Java中提供了一系列和并发处理相关的关键字，比如`volatile`、`synchronized`、`final`、`concurrent`包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

​	在开发多线程的代码的时候，我们可以直接使用`synchronized`等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。

### java内存结构

线程共享：堆（新生代 老年代 永久带java8替换成了元数据区，直接在物理内存上分配空间） 方法区

线程私有：本地方法栈 虚拟机栈 程序计数器

堆(新生代 老年代 永久带，永久带在java8中已经废除了，取而代之的是元空间，它是在本地内存上分配空间) 方法区 虚拟机栈 本地方法栈 程序计数器

### redis的持久化方式有哪些

### springboot的启动过程介绍一下

### 如何进入docker

> docker exec -it  58af372dbc7c  /bin/bash

### redis数据类型

字符串(String) 哈希(Hash) 列表(List) 无序集合(Set) 有序集合(ZSet)

### redis过期策略以及内存淘汰机制

​	Redis 采用的是定期删除+惰性删除策略

​	定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。

​	需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。

​	因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。

也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?

​	不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。

在 redis.conf 中有一行配置：

maxmemory-policy volatile-lru：该配置就是配内存淘汰策略的

- **noeviction：**当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
- **allkeys-lru：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。
- **allkeys-random：**当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
- **volatile-lru：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
- **volatile-random：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
- **volatile-ttl：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。

PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。

### redis缺点

* 缓存和数据库双写一致性问题
* 缓存雪崩:即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常;解决方案：可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效


* 缓存穿透:即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常;解决方案:提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。


* 缓存的并发竞争问题
* 缓存击穿:一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增;解决方案:在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key

### java类加载模型

​	避免一个类被加载多次；关键的类只能由启动类加载器去加载，为了安全考虑
其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，
发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

### 类加载过程

加载 

验证

准备:正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），
，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
public static int value=123;
那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，
所以把value赋值为123的动作将在初始化阶段才会执行。至于“特殊情况”是指：public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶段
初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0 

解析

初始化:初始化阶段是执行类构造器<clinit>()方法的过程,<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，
编译器收集的顺序是由语句在源文件中出现的顺序所决定的。<clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<init>()方法执行之前，父类的<clinit>()方法方法已经执行完毕。
由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。
接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，
父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。
如果在一个类的<clinit>()方法中有好事很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。

使用 卸载

### 进程和线程

- 守护线程：和主线程一起结束的线程，例如垃圾回收线程
- 非守护线程：主线程的结束不影响它的执行，也叫用户线程。

```
主线程执行结束，其他线程一样可以正常执行。

Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程。

java虚拟机(相当于进程)退出的时机是：只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕；反之，如果虚拟机中的线程都是守护线程，那么不管这些线程的死活java虚拟机都会退出。
```

按照操作系统的理论，进程是资源分配的基本单位，线程是CPU调度的基本单位。对于CPU来说，其实并不存在java的主线程和子线程之分，都只是个普通的线程。进程的资源是线程共享的，只要进程还在，线程就可以正常执行，换句话说线程是强依赖于进程的。也就是说，线程其实并不存在互相依赖的关系，一个线程的死亡从理论上来说，不会对其他线程有什么影响。

```java
//获取线程是否是守护线程 true表示是
Thread.currentThread().isDaemon()

 
Thread t1=new Thread(new Runnable() {
			@Override
		public void run() {
			System.out.println("守护线程:"+Thread.currentThread().isDaemon());
		}
	});
//设置线程为守护线程
t1.setDaemon(true);
```

### 数据库三大范式

第一范式：要求确保表中每列的原子性，也就是不可拆分；

第二范式：要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；

第三范式：确保非主键列之间没有传递函数依赖关系，也就是消除传递依赖（消除冗余字段）。

### 数据库隔离级别

读未提交、读已提交、可重复读、可串行化

* 如果不考虑隔离性，事务存在3种并发访问问题

  1、脏读：B事务读取到了A事务尚未提交的数据  

  2、不可重复读：一个事务中两次读取的数据的内容不一致 

  3、幻读/虚读：一个事务中两次读取的数据的数量不一致

* 数据库的隔离级别

  1、read uncommitted : 读未提交 ：哪个问题都不能解决
  2、read committed：读已提交 ：可以解决脏读 —- oracle默认的
  3、repeatable read：可重复读：可以解决脏读和不可重复读 —mysql默认的

  4、serializable：串行化：可以解决脏读不可重复读和虚读—相当于锁表

### mysql死锁

​	是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

那么对应的解决死锁问题的关键就是：让不同的session加锁有次序

### http响应码类型

1XX （信息性状态码）接收的请求正在处理
2XX （成功状态码） 请求正常处理完毕
3XX （重定向状态码） 需要进行附加操作以完成请求
4XX （客户端错误状态码）服务器无法处理请求
5XX （服务器错误状态码）服务器处理请求出错

### equals和==

1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

如果作用于引用类型的变量，则比较的是所指向的对象的地址。

2）对于equals方法，他是object类中的方法，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

### 引用级别

java内存管理分为内存分配和内存回收，都不需要程序员负责，垃圾回收的机制主要看是否有引用指向该对象。

java对象的引用包括

强引用(FinalReference)  软引用(SoftReference)  弱引用(WeakReference) 虚引用(PhantomReference)

Java中提供这四种引用类型主要有两个目的：

​	第一是可以让程序员通过代码的方式决定某些对象的生命周期；

​	第二是有利于JVM进行垃圾回收。

１．强引用

是指创建一个对象并把这个对象赋给一个引用变量。

比如：Object object =new Object();String str =``"hello"``;

强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

> 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象.

2.软引用（SoftReference）

如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。  

SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。

举个例子：

```java
MyObject aRef = new  MyObject();
SoftReference aSoftRef=new SoftReference(aRef); 
```

此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aRef的强引用，所以这个MyObject对象是强可及对象。

随即，我们可以结束aRef对这个MyObject实例的强引用:`aRef = null;`

此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。

使用ReferenceQueue清除失去了软引用对象的SoftReference：

作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:

```java
MyObject aMyObject=new MyObject();
ReferenceQueue queue = new  ReferenceQueue();  
SoftReference  ref=new  SoftReference(aMyObject, queue);
```

那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。

在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。

3.弱引用（WeakReference）

弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：

```java
public static void main(String[] args) {  
  WeakReference<Object>reference=new WeakReference<Object>(new Object());  
  System.out.println(reference.get());  
  System.gc();//通知GVM回收资源  
  System.out.println(reference.get());  
}  
```

4.虚引用（PhantomReference）

　　虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

```java
public class Main {  
    public static void main(String[] args) {  
        ReferenceQueue<String> queue = new ReferenceQueue<String>();  
        PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);  
        System.out.println(pr.get());  
    }  
}  
```

### sleep和wait的区别

1,sleep()是Thread类的静态方法,wait()是Object类的成员方法

2,sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

而当调用wait()方法的时候，线程会释放对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

3,sleep方法需要抛异常,wait方法不需要

4,sleep方法可以在任何地方使用，wait方法只能在同步方法和同步代码块中使用

### X/Open DTP

​	X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由这个厂商进行具体的实现。

X/Open DTP 定义了三个组件： AP，TM，RM

AP(Application Program)：也就是应用程序，可以理解为使用DTP的程序

RM(Resource Manager)：资源管理器，这里可以理解为一个DBMS系统，或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制。资源必须实现XA定义的接口

TM(Transaction Manager)：事务管理器，负责协调和管理事务，提供给AP应用程序编程接口以及管理资源管理器

其中，AP 可以和TM 以及 RM 通信，TM 和 RM 互相之间可以通信，DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信，例如:TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。AP和RM之间则通过RM提供的Native API 进行资源控制。

​	XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。XA之所以需要引入事务管理器是因为，在分布式系统中，两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源（如[数据库](http://lib.csdn.net/base/mysql)或JMS队列）

​	2pc：两阶段提交，定义了TM和RM之间通信的规范。

​	



## 解决方案

### 如何控制一个用户只能在一台设备上在线

问题描述：如果张三在a电脑上已经登录了，就不能在其他电脑上登录了

借助redis，将张三的登录账号做为key缓存起来，缓存的过期时间和session的过期时间一致。在网关做登录校验，如果存在key说明已经登录过来，就不能再次登录了。再退出账号的时候删除redis的key。

### 如果控制在同一个用户在500ms内重复提交数据

首先需要维护一个需要做重复校验的url

其次在redis里边需要缓存一个key=url+usercode的数据，设置有效期为500ms

在网关层每次请求的时候首先判断这个url是否需要校验，如果需要，判断redis是否存在这个key，如果不存在就进行缓存，如果存在就拒绝这次请求。

### 分布式唯一ID生成方案

* redis生成ID

  redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的

* 数据库自增ID

  使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用

* UUID