# 第二阶段面试

### Minor GC的触发条件

当Eden区满时，触发Minor GC。

### Full GC触发的条件

1、调用 System.gc()

此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()。

2、老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。

3、空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。

4、JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的`方法区是用永久代实现的`，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

5、Concurrent Mode Failure

发生在cms的清理sweep阶段,发现有新的垃圾产生,而且老年代没有足够空间导致的.
关于cms:
初始标记(STW) - >并发标记　－＞重新标记（STW）　－＞并发清除．
STW = stop the world

###  String  StringBuffer StringBuilder区别

String是不可变的，创建后如何修改的时候，会产生新的对象。

StringBuffer 是线程安全的，并且可以通过append 和insert方法修改对象的值，不会产生新对象

StringBuilder是线程不安全的，并且可以通过append 和insert方法修改对象的值，不会产生新对象

### Error和Exception区别

error指的是不可预料的错误，绝大部分error都会导致程序处于非正常、不可恢复的状态。不需要对这种异常捕获处理

exception值的是可以预料的错误，并且需要进行捕获，进行相应的处理

### HashMap和HashTable区别

HashMap线程不安全，可以存储null key和null value，默认的初始容量为16，数据结构为数组+单向链表+红黑树

HashTable线程安全，不能存储null key和null value，默认的初始容量为11，数据结构为数组+单向链表

### HashMap和ConcurrentHashMap区别

HashMap线程不安全,主要体现在put时

ConcurrentHashMap线程安全，通过synchronized+cas来实现线程安全的，加同步锁的时候只锁定单个node

### java中有哪些方式可以实现一个线程？同步有那几种实现方式？

继承Thread类，或者实现callable接口、runnable接口，或者通过线程池

synchronized或者ReentrantLock#lock

### 介绍线程池以及拒绝策略

1.线程池的核心参数如下：

核心线程数 int corePoolSize

最大线程数 int maximumPoolSize

空闲线程回收时间 long keepAliveTime

空闲线程回收时间单位 TimeUnit unit

阻塞队列 BlockingQueue<Runnable> workQueue

ThreadFactory threadFactory

拒绝策略	RejectedExecutionHandler handler

2.拒绝策略

 AbortPolicy 默认，直接抛异常

```java
public static class AbortPolicy implements RejectedExecutionHandler {
  //直接抛异常
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    throw new RejectedExecutionException("Task " + r.toString() +
                                         " rejected from " +
                                         e.toString());
  }
}
```

DiscardPolicy  正常执行不处理

```java
public static class DiscardPolicy implements RejectedExecutionHandler {  
  //并没有做任何处理
  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
  }
}
```

DiscardOldestPolicy 将当前任务加入队尾，移除并返回之前的队列头部线程，如果队列为空则返回null，如果执行线程池关闭了，那么就放弃这个任务

```java
public static class DiscardOldestPolicy implements RejectedExecutionHandler {

  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
      e.getQueue().poll();//移除并返回队列的头部元素，如果队列为空则返回null
      e.execute(r);//将当前任务加入队尾
    }
  }
}
```

CallerRunsPolicy 将这些被拒绝的线程用当前调用它们的线程执行这些任务 例如：线程2被拒绝，是main线程调用这个线程开启的任务，因此我们直接去使用main的线程执行这些被拒绝的任务，如果执行线程池关闭了，那么就放弃这个任务

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {

  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
      r.run();
    }
  }
}
```

### synchronized 和lock的区别

- synchronized 是java的关键字，lock是一个java接口


- synchronized 释放锁的时机是执行完同步代码块或同步方法

  ​lock获取锁锁调用lock.lock,释放锁调用lock.unlock

  ​如果一个线程获取了synchronized锁，此时又来了一个线程想要获取锁，只能阻塞等待，不能被中断
  ​但是lock就可以中断处于阻塞状态的线程

- synchronized互斥的场景有 读和读 读和写 写和写

  ​但是lock 只有读和写 写和写互斥 ，读和读共享lock

- 公平锁：按照请求锁的时间，先来的先获取锁，反之称为非公平锁

  ​synchronized 是非公平锁

  lock支持公平锁和非公平锁

### java对象如何实现序列化

让类实现Serializable接口,该接口是一个标志接口,标注该类对象是可被序列

然后使用一个输出流来构造一个对象输出流并通过writeObect(Obejct)方法就可以将实现对象写出

如果需要反序列化,则可以用一个输入流建立对象输入流,然后通过readObeject方法从流中读取对象

### java内存溢出问题如何排查

通过增加了参数 -XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath ，在发成内存溢出的时候生成dump文件，并且通过mat工具分析

### linux系统vi中删除光标所在行采用什么命令

连续输入两次小写的d，即dd

### 列举web中存储用户登录信息的方法，并简述优缺点

传统的session存储；cookie存储；redis存储

### oracle中PreparedStatement 和statement的区别

preparedStatement可以使用占位符，是预编译的，批处理比Statement效率高    

prepareStatement对象防止sql注入的方式是把用户非法输入的单引号用\反斜杠做了转义，从而达到了防止sql注入的目的

### oralce中truncate和delete命令的区别

delete 是dml，只删除数据，不会释放空间

truncate 是ddl，删除后会立马生效，不能回滚，会删除数据并且释放空间

### mysql聚集索引和非聚集索引

mysql的索引类型

主键索引（聚集索引）、唯一索引、全文索引、非聚集索引

聚集索引（针对的是innodb引擎）

1.数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

2.叶子节点存放的就是整行数据，直接可以通过这个聚集索引找到对应的数据

3.一个表只能存在一个聚集索引

4.mysql的innodb存储引擎，默认通过主键聚集数据，如果一个表没有主键和一个不为null的唯一索引，InnoDB将会自动增加一个6字节（48位）的整数列，被叫做行ID，聚集数据都是依靠这列的。

非聚集索引（针对的是innodb引擎）

1.数据的物理存放顺序与索引顺序不一致。

2.叶子节点存放的索引覆盖列的值和聚集索引覆盖的列数据

3.一个表可以有多个非聚集索引

4.如果查询涉及到索引未覆盖的列，会根据查询到的聚集索引进行二次查询（回表），可以创建复合索引来解决这个问题

### MyISAM与InnoDB两者之间区别

| 功能点        | innodb                                   | myisam                                   |
| ---------- | ---------------------------------------- | ---------------------------------------- |
| 事物         | 支持事物，默认autocommit是打开的，即每条sql都会被封装成一个事物，自动提，交这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交 | 不支持事物                                    |
| 存储结构       | 在磁盘上存储成两个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据索引文件的扩展名为.ibd。InnoDB表的大小只受限于操作系统文件的大小，一般为2GB | 在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex) |
| 存储空间       | 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引   | 可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 |
| 可移植性、备份及恢复 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。 | 数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 |
| 表锁差异       | 支持表锁和行级锁。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。 | 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 |
| 全文索引       | MySQL 5.6 及以后的版本 ，MyISAM 和 InnoDB 存储引擎均支持全文索引; | MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引     |
| 表的具体行数     | 没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 | 保存有表的总行数，如果select count(*) from table;会直接取出出该值 |
| 外键         | 支持                                       | 不支持                                      |

### mysql慢查询优化

1.开启慢查询日志：set slow_query_log=ON，分析慢查询日志

2.根据执行计划(explain)分析，确认是否走索引（type这列显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL）

3.根据数据量判断是否要进行分表操作

### 分布式锁的实现方式有那几种

redis+lua脚本

数据库唯一键

zookeeper临时有序节点

### 介绍jwt

分为三部分，header payload 签名

header+payload+秘钥生成签名，防止传输过程被被人修改

### Ribbon实现原理

Spring Cloud Ribbon是一个基于HTTP和TCP的`客户端负载均衡工具`，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。

客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到`服务清单所存储的位置`。在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端端清单来自于服务注册中心，比如Eureka服务端。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，默认会创建针对各个服务治理框架的Ribbon自动化整合配置.

        通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用非常简单，只需要如下两步：

        ▪️服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。

        ▪️服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。

        这样，我们就可以将服务提供者的高可用以及服务消费者的负载均衡调用一起实现了

### zuul和eureKa优化

### zuul和spring getaway区别

### hystrix原理

Hystrix的目标就是能够在1个或多个依赖出现问题时，系统依然可以稳定的运行，其手段包括隔离、限流和降级等。

#### 隔离

隔离说到底还是**分治思想**的体现，在当前场景中，就是将不同的外部依赖进行分类，确定其边界，然后隔离开来分开进行管理。Hystrix支持的隔离策略`isolationStrategy`包括`信号量`和`线程池`两种

#### 限流

在基于服务化（包括SOA和微服务）的系统架构中，对服务请求进行限流是保护服务稳定性的一个常见手段。此外，关于限流有两个比较重要的概念：限流算法，包括计数限流、令牌桶和漏桶等；限流粒度，包括方法级别、接口级别、应用级别、集群级别等。对于Hystrix来说，其采用了自己的一套限流方式，这里首先延续之前隔离知识中提到的信号量和线程池概念进行介绍。

**信号量**概念比较简单，常用于获取共享资源的场景中，比如计算机连接了两个打印机，那么初始的信号量就是2，被某个进程或线程获取后减1，信号量为0后，需要获取的线程或进程进入资源等待状态。Hystrix的处理有些不同，其不等待，直接返回失败。

**线程池**采用的就是jdk的线程池，其默认选用不使用阻塞队列的线程池，例如线程池大小为10，如果某时刻10个线程均被使用，那么新的请求将不会进入等待队列，而是直接返回失败，起到限流的作用。

此外，其还引入了一个**断路器**机制，当断路器处于打开状态时，直接返回失败或进入降级流程。断路器打开和关闭的触发流程为：当总的请求数达到可阈值`HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()`，或总的请求失败百分比达到了阈值`HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()`，这时将断路器的状态由关闭设置为打开。当断路器打开时，所有的请求均被短路，在经过指定`休眠时间窗口`后，让下一个请求通过（断路器被认为是半开状态）。如果请求失败，断路器进入打开状态，并进入新的休眠窗口；否则进入关闭状态。

#### 降级

这里的降级具体来说就是服务质量的降级，需要注意的是，只有方法所属的业务场景适合降级时才采用，一般为查询场景。Hystrix通过配置`fallbackMethod`指定降级时的处理方法，触发降级动作的4种情况如下所示。

- run()方法抛出非HystrixBadRequestException异常。
- run()方法调用超时
- 熔断器开启拦截调用
- 线程池/队列/信号量是否跑满

### linux常用命令

cd pwd ls cp top move mkdir

杀进程 kill pixd

删除文件 rm -rf xxx

查看文件内容cat、vim、 tail -f、 more 

查看进程信息 ps -ef|grep java 

查看内存的使用情况 free -m 

显示已经挂载的分区列表  df -h 

解压缩文件 tar -zxvf xxx 

### 自己如何实现spring starter

* 引入相关的依赖jar


* 创建`resources/MATA-INF/spring.factories`文件，并编写需要自动装配的类（利用spring的spi机制），例如

```xml
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.dong.Demo
```

* 在自动注入的类上添加对应的`@ConditionalOnxxx`主键，达到条件装配的效果,例如：

```java
@ConditionalOnProperty(value = "spring.application.enabled", havingValue = "true",matchIfMissing = false)
```

### spring bean的生命周期

#### 四个阶段：

* 实例化（AbstractAutowireCapableBeanFactory#createBeanInstance）


* 属性赋值(AbstractAutowireCapableBeanFactory#populateBean)


* 初始化(AbstractAutowireCapableBeanFactory#initializeBean)


* 销毁（关闭容器的时候出发）

#### 常用的扩展点

##### 第一大类 影响多个Bean的接口

实现了这些接口的bean会切入到多个bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。

* BeanPostProcessor
* InstantiationAwareBeanPostProcessor

这两兄弟可能是Spring扩展中最重要的两个接口！InstantiationAwareBeanPostProcessor作用于实例化阶段的前后，BeanPostProcessor作用于初始化阶段的前后。正好和第一、第三个生命周期阶段

##### 第二大类 只调用一次的接口

这一大类接口的特点是功能丰富，常用于用户自定义扩展。

第二大类中又可以分为两类：

- Aware类型的接口
- 生命周期接口

Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如BeanNameAware可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在初始化阶段之前调用的！

Aware接口众多，这里同样通过分类的方式帮助大家记忆。

Aware接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是Aware接口的执行顺序，能够见名知意的接口不再解释。

**Aware Group1**

- BeanNameAware
- BeanClassLoaderAware
- BeanFactoryAware

**Aware Group2**

- EnvironmentAware
- EmbeddedValueResolverAware 这个知道的人可能不多，实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用，非常方便。
  - ApplicationContextAware(ResourceLoaderAwareApplicationEventPublisherAwareMessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口

### spring aop spring ioc

IOC： Inversion of Control，IOC就是控制反转，通俗的说就是我们不用自己创建实例对象，这些都交给Spring的bean工厂帮我们创建管理。这也是Spring的核心思想，通过面向接口编程的方式来是实现对业务组件的动态依赖。这就意味着IOC是Spring针对解决程序耦合而存在的。在实际应用中，Spring通过配置文件（xml或者properties）指定需要实例化的java类（类名的完整字符串），包括这些java类的一组初始化值，通过加载读取配置文件，用Spring提供的方法（getBean()）就可以获取到我们想要的根据指定配置进行初始化的实例对象。

**Spring中IOC的三种实现方式:**

1.set方法注入；2.构造方法注入；3.注解注入

AOP就是将程序功能中的频繁出现或者与主业务逻辑代码相关度不高的代码抽离出来，通过切面编程的方式在想要调用的时候引入调用的思想。AOP（面向切面）和OOP（面向对象）一样都是一种编程思想，这种思想的实现机制在Spring中便是应用了java的动态代理和java的反射。在实际编程中，我们通常会遇到一些交叉业务逻辑（比如：日志，事务，安全等等），这是我们就可以封装一个封面，然后注入到目标对象（具体的业务逻辑）中去。这种在调用某个方法之前/后想要自动执行一系列自定义操作的就是AOP思想。

总结：

IOC即控制反转，一种将控制权转移的设计模式，由传统的程序控制转移到容器控制；

DI即依赖注入，将相互依赖的对象分离，在Spring的配置（注解）中描述它们之间的依赖关系，这些依赖关系也只在使用时才被建立。

AOP即面向切面，一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。

### spring 事物的传播性

| 事务传播行为类型                  | 说明                                       |
| ------------------------- | ---------------------------------------- |
| PROPAGATION_REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是默认的。 |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行。               |
| PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，就抛出异常。                  |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。                   |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。            |
| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。                 |
| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

### 使用spring boot 的版本

```xml
<parent>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-parent</artifactId>
  <version>1.5.9.RELEASE</version>
  <relativePath />
</parent>
```

### 使用spring cloud的版本

```xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-dependencies</artifactId>
  <version>Edgware.SR3</version>
  <type>pom</type>
  <scope>import</scope>
</dependency>
```




# 第一阶段面试

## 知识型

### 什么是断言，使用场景

断言是java1.4新特性，对参数进行判断,主要用在测试阶段和开发阶段,默认是关闭的，可以使用`-ea启用`，`-da禁用`;语法如下:assert <布尔表达式>assert <布尔表达式>:<错误信息>如果布尔表达式为，程序继续执行，如果布尔表达式为假，抛出AssertionError错误，程序结束运行。

### 实参和形参

形参指的就是方法的参数列表。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

### 什么是可变参数

参数的个数是不固定的(Object ... obj),其实这就是java的语法糖，在后期处理的时候是按照数组处理的。(1)一个方法只能有一个可变参数，并且只能是最后一个形参。(2)因为底层是按数组处理，所以以下这种并不是重载，会编译报错。

```
public void a(String [] args){}public void a(String ... args){}

```

(3)主函数调用形参是可变函数时，可以传入一个类型一致的数组;也可以传入多个类型一致的实参;也可以不传;如果存在这样的两个重载的方法，在不传参数的情况下，调用的是没有参数的函数。

```
public void a(){}public void a(String ... args){}

```

### 什么是跨域请求，跨域请求有哪些解决方法

在 HTML 中，`, , , , , ` 等标签以及 Ajax 都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为协议 + 域名 + 端口号相同，那么就是同域。浏览器的同源策略，会对跨域请求做限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动CSRF攻击。解决方法：1>jsonpJSONP 本质上是利用 `` 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段Javascript代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求

2>nodejs代理3>nginx代理4>cors(跨域资源共享)是W3C标准，它新增的一组HTTP头字段，允许服务端其声明哪些源站有权限访问哪些资源。CORS分为简单请求和复杂请求，处理方法也是有不同的，所以我们分别总结:

同时满足以下两个条件，就是简单请求：请求方式是下列之一：HEADGETPOSTHTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain实现方法非常简单，只需要把服务器的响应报文里的Access-Control-Allow-Origin设置为*或者包含由 Origin指明的站点。

复杂请求如果不是简单请求，那就是复杂请求，比如请求的方法是PUT或者DELETE，比如Content-Type字段的类型是application/json，比如设置了自定义头信息。复杂请求就是比简单请求多了个预检请求（preflight）而已。预检请求就是浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，还有两个字段非常重要：Access-Control-Request-Method和Access-Control-Request-Headers，分别表示允许的请求方法和请求头。

举一个具体的例子：现在，我们有一个页面向服务器发送了一个POST请求，并且我们自己定义了一个请求头字段My-HEADER，这时候浏览器就会首先发送一个OPTION请求来做预检请求，请求头里有以下字段：

Access-Control-Request-Method: POSTAccess-Control-Request-Headers: My-HEADER如果预检请求成功的话，响应头里的内容如下：

Access-Control-Allow-Origin: [http://example.com](http://example.com) //表明服务器允许[http://example.com](http://example.com)的请求Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法Access-Control-Allow-Headers: My-HEADER //传递一个可接受的自定义请求头列表Access-Control-Max-Age: 3000000 //告诉浏览器，本次预检请求的响应结果有效时间是多久

### 常见的sql查询优化

1> 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引2> 很多时候用 exists 代替 in 是一个好的选择3> 当索引列有大量数据重复时，SQL查询可能不会去利用索引,创建索引一定要选离散性好的列。4> 索引并不是越多越好，索引可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引。一个表的索引数最好不要超过6个，太多则应考虑一些不常使用到的列上建的索引是否有必要。5> 提高GROUP BY 语句的效率，可以通过将不需要的记录在GROUP BY 之前过滤掉

### 什么情况下索引会失效，会导致扫描全表

1> a表的name字段有索引，如果使用like '%张三'会导致索引失效，如果like '张三%'则不会;2> a表的name字段有索引，where name!='张三'或者name<>'张三'会导致索引失效;3> a表的name字段有索引，age字段没有索引，where name='张三' or age=10 会导致索引失效;如果两个字段都有索引则不会失效；把or改成union all 索引就不会失效

4> not in也会导致索引失效5> a表的age字段有索引，where age/20=100会导致索引失效，where age=100*20则不会，所以不要在where子句对字段进行表达式操作6> a表name有索引，where concat(name,'12')='sdd12' 会导致索引失效。7> 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。8> a表sex有索引，但是sex的值大部分都是0，where sex='0'就会导致索引失效，创建索引一定要选离散性好的列。9> a表age字段有索引，where age>1 会导致索引失效，但是如果where age>1 and age<10则会使用索引。 

### 乐观锁和悲观锁的理解以及使用场景

​	乐观锁总是假设最好的情况，每次拿数据的时候总认为别人不会修改，所以不会上锁，但是在更新的时候会判断在此期间有没有被别人修改过；可以通过数据库加版本号或者cas实现乐观锁。乐观锁主要用在多读的场景。

​	悲观锁总是假设最坏的情况，每次拿数据的时候都会上锁，别的线程只能阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。关系型数据库的表锁 行锁 读锁 写锁都是在操作前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。悲观锁主要用在多写的场景。

### 自旋锁

​	Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因为状态装换需要耗费很多的处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还要长。虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和恢复现场并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。

是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。

锁的本质就是线程等待，可以分为线程阻塞和线程自旋:阻塞：要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源。如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间， 如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。

自旋：如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换，只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。（线程还是Runnable的，只是在执行空代码。当然一直自旋也会白白消耗计算资源。）

自旋锁存在的问题:

​	如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。​	上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。

自旋锁的优点:

​	自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是运行的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

​	非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。(线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能)

### java的锁

公平锁和非公平锁乐观锁和悲观锁轻量级锁 重量级锁 偏向锁自旋锁锁粗化 锁消除类锁和对象锁 可重入锁共享锁和排它锁共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据互斥锁:指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。读写锁:一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。

### 内核态和用户态

内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。

因为操作系统的很多操作会消耗系统的物理资源，例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息等，这些操作显然不能随便让任何程序都可以做，于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这样可以做到集中管理，减少有限资源的访问和使用冲突。Intel的X86架构的CPU提供了0到3四个特权级，而在我们Linux操作系统中则主要采用了0和3两个特权级，也就是我们通常所说的内核态和用户态。

运行于用户态的进程可以执行的操作和访问的资源都受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上也没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。这里再明确一个概念，每个进程都有一个4G大小的虚拟地址空间，在这个4G大小的虚拟地址空间中，前0～3G为用户空间，每个进程的用户空间之间是相互独立的，互不相干。而3G～4G为内核空间，内核空间中大部分区域对于所有的进程来说都是共享的，这不共享的小部分区域是存储所有进程内核栈的区域，为什么这么说，因为每个进程都存在一个内核栈，而各个进程的内核栈之间一定是不共享的。

### ThreadLocal

为变量在每个线程中都创建了一个副本

### spring项目打包

> mvn clean package spring-boot:repackage -DskipTests

### 线程有几种状态

java中，线程的状态使用一个枚举类型来描述的。这个枚举一共有6个值新建(NEW);就绪(RUNNABLE)

阻塞(BLOCKED):阻塞表示线程在等待Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。

等待(WAITING):表示正在等待其他线程采取某些操作

计时等待(TIMED_WAITING)

终止(TERMINATED)

### java内存模型

​	java内存模型是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。

​	为了屏蔽操作系统的差异，解决并发编程的原子性 可见性 有序性的问题，抽象出来了java内存模型，他其实和jvm一样，也是一个规范。共享变量存放在主内存，每个线程都有自己的工作内存，工作内存会缓存和自己相关的变量副本，当两个线程同时访问一个共享变量的时候就会存在以上说的并发编程的问题。

#### CPU和缓存一致性

​	我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。

​	刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。

​	所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。

那么，程序的执行过程就变成了：

​	当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

​	而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。

按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。

这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。

那么，在有了多级缓存之后，程序的执行就变成了：

​	当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。

单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。

![img](https://img-blog.csdn.net/20180706172557116?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTY0MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。

- 单线程、cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。
- 单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。
- 多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。

在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。

![img](https://img-blog.csdn.net/20180706185956933?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTY0MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 处理器优化和指令重排

​	上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。

​	除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。

​	可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。

#### 并发编程的问题

​	前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性，可见性和有序性问题。

​	其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。

​	我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：

原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

有序性即程序执行的顺序按照代码的先后顺序执行。

​	有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。

#### 什么是内存模型

​	前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？

​	最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。

​	所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。

​	为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

​	内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。

#### 什么是Java内存模型

​	前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。

​	我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

​	提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型。

​	Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。

![img](https://img-blog.csdn.net/20180709193649114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTY0MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

​	在Java中提供了一系列和并发处理相关的关键字，比如`volatile`、`synchronized`、`final`、`concurrent`包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

​	在开发多线程的代码的时候，我们可以直接使用`synchronized`等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。

### java内存结构

线程共享：堆（新生代 老年代 永久带java8替换成了元数据区，直接在物理内存上分配空间） 方法区

线程私有：本地方法栈 虚拟机栈 程序计数器

堆(新生代 老年代 永久带，永久带在java8中已经废除了，取而代之的是元空间，它是在本地内存上分配空间) 方法区 虚拟机栈 本地方法栈 程序计数器

### redis的持久化方式有哪些

### springboot的启动过程介绍一下

### 如何进入docker

> docker exec -it  58af372dbc7c  /bin/bash

### redis数据类型

字符串(String) 哈希(Hash) 列表(List) 无序集合(Set) 有序集合(ZSet)

### redis过期策略以及内存淘汰机制

​	Redis 采用的是定期删除+惰性删除策略

​	定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。

​	需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。

​	因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。

也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?

​	不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。

在 redis.conf 中有一行配置：

maxmemory-policy volatile-lru：该配置就是配内存淘汰策略的

- **noeviction：**当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
- **allkeys-lru：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。
- **allkeys-random：**当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
- **volatile-lru：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
- **volatile-random：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
- **volatile-ttl：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。

PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。

### redis缺点

使用缓存后的请求过程

1.第一种情况：查询数据先查redis，如果redis存在，直接返回

2.第二种情况：查询数据先查redis，如果redis不存在，就查数据库，如果数据库存在，返回数据本把它缓存到redis，下次查询就会走第一种情况

3.第三种情况：查询数据先查redis，如果redis不存在，就查数据库，如果数据库不存在，就返回null。

- 缓存和数据库双写一致性问题
- 缓存雪崩:即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常;解决方案：可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效


- 缓存穿透:即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常;解决方案:提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。

  ​	Bloom Fliter（只能添加数据，不能删除数据） 或者Counting Bloom Filter(带计数器的布隆过滤器，这样可以实现删除指定的数据)


- 缓存击穿:一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增;解决方案:在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key
- 缓存的并发竞争问题

### java类加载模型

​	避免一个类被加载多次；关键的类只能由启动类加载器去加载，为了安全考虑其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

### 类加载过程

加载 

验证

准备:正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：public static int value=123;那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。至于“特殊情况”是指：public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0 

解析

初始化:初始化阶段是执行类构造器<clinit>()方法的过程,<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。<clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<init>()方法执行之前，父类的<clinit>()方法方法已经执行完毕。由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有好事很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。

使用 卸载

### 进程和线程

- 守护线程：和主线程一起结束的线程，例如垃圾回收线程
- 非守护线程：主线程的结束不影响它的执行，也叫用户线程。

```
主线程执行结束，其他线程一样可以正常执行。

Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程。

java虚拟机(相当于进程)退出的时机是：只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕；反之，如果虚拟机中的线程都是守护线程，那么不管这些线程的死活java虚拟机都会退出。
```

按照操作系统的理论，进程是资源分配的基本单位，线程是CPU调度的基本单位。对于CPU来说，其实并不存在java的主线程和子线程之分，都只是个普通的线程。进程的资源是线程共享的，只要进程还在，线程就可以正常执行，换句话说线程是强依赖于进程的。也就是说，线程其实并不存在互相依赖的关系，一个线程的死亡从理论上来说，不会对其他线程有什么影响。

```
//获取线程是否是守护线程 true表示是Thread.currentThread().isDaemon()​ Thread t1=new Thread(new Runnable() {            @Override        public void run() {            System.out.println("守护线程:"+Thread.currentThread().isDaemon());        }    });//设置线程为守护线程t1.setDaemon(true);

```

### 数据库三大范式

第一范式：要求确保表中每列的原子性，也就是不可拆分；

第二范式：要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；

第三范式：确保非主键列之间没有传递函数依赖关系，也就是消除传递依赖（消除冗余字段）。

### 数据库隔离级别

读未提交、读已提交、可重复读、可串行化

- 如果不考虑隔离性，事务存在3种并发访问问题

  1、脏读：B事务读取到了A事务尚未提交的数据  

  2、不可重复读：一个事务中两次读取的数据的内容不一致 

  3、幻读/虚读：一个事务中两次读取的数据的数量不一致

- 数据库的隔离级别

  1、read uncommitted : 读未提交 ：哪个问题都不能解决2、read committed：读已提交 ：可以解决脏读 —- oracle默认的3、repeatable read：可重复读：可以解决脏读和不可重复读 —mysql默认的

  4、serializable：串行化：可以解决脏读不可重复读和虚读—相当于锁表

参考地址[https://blog.csdn.net/weixin_41835916/article/details/81455953](https://blog.csdn.net/weixin_41835916/article/details/81455953)

### mysql死锁

​	是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

那么对应的解决死锁问题的关键就是：让不同的session加锁有次序

### http响应码类型

1XX （信息性状态码）接收的请求正在处理2XX （成功状态码） 请求正常处理完毕3XX （重定向状态码） 需要进行附加操作以完成请求4XX （客户端错误状态码）服务器无法处理请求5XX （服务器错误状态码）服务器处理请求出错

### equals和==

1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

如果作用于引用类型的变量，则比较的是所指向的对象的地址。

2）对于equals方法，他是object类中的方法，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

### 引用级别

java内存管理分为内存分配和内存回收，都不需要程序员负责，垃圾回收的机制主要看是否有引用指向该对象。

java对象的引用包括

强引用(FinalReference)  软引用(SoftReference)  弱引用(WeakReference) 虚引用(PhantomReference)

Java中提供这四种引用类型主要有两个目的：

​	第一是可以让程序员通过代码的方式决定某些对象的生命周期；

​	第二是有利于JVM进行垃圾回收。

１．强引用

是指创建一个对象并把这个对象赋给一个引用变量。

比如：Object object =new Object();String str =`"hello"`;

强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

> 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象.

2.软引用（SoftReference）

如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。  

SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。

举个例子：

```
MyObject aRef = new  MyObject();SoftReference aSoftRef=new SoftReference(aRef); 

```

此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aRef的强引用，所以这个MyObject对象是强可及对象。

随即，我们可以结束aRef对这个MyObject实例的强引用:`aRef = null;`

此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。

使用ReferenceQueue清除失去了软引用对象的SoftReference：

作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:

```
MyObject aMyObject=new MyObject();ReferenceQueue queue = new  ReferenceQueue();  SoftReference  ref=new  SoftReference(aMyObject, queue);

```

那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。

在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。

3.弱引用（WeakReference）

弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：

```
public static void main(String[] args) {    WeakReference<Object>reference=new WeakReference<Object>(new Object());    System.out.println(reference.get());    System.gc();//通知GVM回收资源    System.out.println(reference.get());  }  

```

4.虚引用（PhantomReference）

　　虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

```
public class Main {      public static void main(String[] args) {          ReferenceQueue<String> queue = new ReferenceQueue<String>();          PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);          System.out.println(pr.get());      }  }  

```

### sleep和wait的区别

1,sleep()是Thread类的静态方法,wait()是Object类的成员方法

2,sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。

而当调用wait()方法的时候，线程会释放对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

3,sleep方法需要抛异常,wait方法不需要

4,sleep方法可以在任何地方使用，wait方法只能在同步方法和同步代码块中使用

### X/Open DTP

​	X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由这个厂商进行具体的实现。

X/Open DTP 定义了三个组件： AP，TM，RM

AP(Application Program)：也就是应用程序，可以理解为使用DTP的程序

RM(Resource Manager)：资源管理器，这里可以理解为一个DBMS系统，或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制。资源必须实现XA定义的接口

TM(Transaction Manager)：事务管理器，负责协调和管理事务，提供给AP应用程序编程接口以及管理资源管理器

其中，AP 可以和TM 以及 RM 通信，TM 和 RM 互相之间可以通信，DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信，例如:TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。AP和RM之间则通过RM提供的Native API 进行资源控制。

​	XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。XA之所以需要引入事务管理器是因为，在分布式系统中，两台机器理论上无法达到一致的状态，需要引入一个单点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源（如[数据库](http://lib.csdn.net/base/mysql)或JMS队列）

​	2pc：两阶段提交，定义了TM和RM之间通信的规范。

### Thread.yield()

​	让当前线程状态从运行状态变成可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

```
public static void main(String[] args) throws Exception {  Thread t1=new Thread(new MyTestThread(),"线程1");  Thread t2=new Thread(new MyTestThread(),"线程2");  t1.start();  t2.start();}​static class MyTestThread implements Runnable{​  @Override  public void run() {    for (int i = 0; i < 10; i++) {      System.out.println(Thread.currentThread().getName()+":"+ i);      if(i==5&&Thread.currentThread().getName().equals("线程1")){        Thread.yield();      }    }  } }

```

输出结果如下:

![微信截图_20190628141511](C:\Users\pc007\Desktop\微信截图_20190628141511.png)

### oracle 分页查询

1.ORACLE使用ROWNUM是一个伪列，查询数据才会生成的数值1,2,3,4 作用是用于实现ORACLE的分页必须使用子查询实现

2.别名问题:由于ROWNUM的WHERE判断执行在SELECT关键字之前。当前查询中的ROWNUM别名不能用于条件做判断，别名只可以用一外部条件判断

3.含order by排序的分页要多一层嵌套，因为order by在select之后执行

以上三点解释了为什么要写两次或者三层来解决分页查询的问题。

```
/*无排序的分页sql*/select * from (select t.*,rownum num from tb_page_test t) t where t.num>1 and t.num<5;​/*有排序的分页sql*/select t.*,t.num from (select temp.*,rownum  as num from (select t.* from tb_page_test t order by id desc) temp) t where t.num>1 and t.num<5;

```

### mysql in和exists区别

​	exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false

​	in查询相当于多个or条件的叠加。

​	in查询的子条件返回结果必须只有一个字段，而exists就没有这个限制。

结论

MySQL中的in语句是把外表和内表作join连接，而exists语句是对外表作nest loop循环，每次loop循环再对内表进行查询。

1、如果查询的两个表大小相当，那么用in和exists差别不大。2、如果两个表中一个表大，另一个是表小，那么IN适合于外表大而子查询表小的情况。3、如果两个表中一个表大，另一个是表小，EXISTS适合于外表小而子查询表大的情况。

在一般情况下确实如此，这里需要考虑到索引原因。但特殊情况是什么情况呢？我目前也不知道。

### HashMap和ConcurrentHashMap区别

参考文章：[https://blog.csdn.net/u013256816/article/details/84113163](https://blog.csdn.net/u013256816/article/details/84113163)

### spring bean的生命周期

参考链接 [https://www.jianshu.com/p/1dec08d290c1](https://www.jianshu.com/p/1dec08d290c1)

Spring Bean的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。在这四步之间穿插的各种扩展点，稍后会讲。

1. 实例化 Instantiation
2. 属性赋值 Populate
3. 初始化 Initialization
4. 销毁 Destruction

实例化 -> 属性赋值 -> 初始化 -> 销毁

主要逻辑都在AbstractAutowireCapableBeanFactory#doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。

1. createBeanInstance() -> 实例化
2. populateBean() -> 属性赋值
3. initializeBean() -> 初始化

常用扩展点

Spring生命周期相关的常用扩展点非常多，所以问题不是不知道，而是记不住或者记不牢。其实记不住的根本原因还是不够了解，这里通过源码+分类的方式帮大家记忆。

#### 第一大类：影响多个Bean的接口

实现了这些接口的Bean会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。

- BeanPostProcessor
- InstantiationAwareBeanPostProcessor

这两兄弟可能是Spring扩展中**最重要**的两个接口！InstantiationAwareBeanPostProcessor作用于**实例化**阶段的前后，BeanPostProcessor作用于**初始化**阶段的前后。正好和第一、第三个生命周期阶段对应。

#### 第二大类：只调用一次的接口

这一大类接口的特点是功能丰富，常用于用户自定义扩展。第二大类中又可以分为两类：

1. Aware类型的接口
2. 生命周期接口

##### 无所不知的Aware

Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如`BeanNameAware`可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在初始化阶段之前调用的！Aware接口众多，这里同样通过分类的方式帮助大家记忆。Aware接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是Aware接口的执行顺序，能够见名知意的接口不再解释。

`Aware Group1`

1. BeanNameAware
2. BeanClassLoaderAware
3. BeanFactoryAware

`Aware Group2`

1. EnvironmentAware
2. EmbeddedValueResolverAware 这个知道的人可能不多，实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用，非常方便。
3. ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口，如下：

总结：

Spring Bean的生命周期分为`四个阶段`和`多个扩展点`。扩展点又可以分为`影响多个Bean`和`影响单个Bean`。整理如下：四个阶段

- 实例化 Instantiation
- 属性赋值 Populate
- 初始化 Initialization
- 销毁 Destruction

多个扩展点

- 影响多个Bean
  - BeanPostProcessor
  - InstantiationAwareBeanPostProcessor
- 影响单个Bean
  - Aware
    - Aware Group1
      - BeanNameAware
      - BeanClassLoaderAware
      - BeanFactoryAware
    - Aware Group2
      - EnvironmentAware
      - EmbeddedValueResolverAware
      - ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)
  - 生命周期
    - InitializingBean
    - DisposableBean

## 解决方案

### 如何控制一个用户只能在一台设备上在线

问题描述：如果张三在a电脑上已经登录了，就不能在其他电脑上登录了

借助redis，将张三的登录账号做为key缓存起来，缓存的过期时间和session的过期时间一致。在网关做登录校验，如果存在key说明已经登录过来，就不能再次登录了。再退出账号的时候删除redis的key。

### 如果控制在同一个用户在500ms内重复提交数据

首先需要维护一个需要做重复校验的url

其次在redis里边需要缓存一个key=url+usercode的数据，设置有效期为500ms

在网关层每次请求的时候首先判断这个url是否需要校验，如果需要，判断redis是否存在这个key，如果不存在就进行缓存，如果存在就拒绝这次请求。

### 分布式唯一ID生成方案

- redis生成ID

  redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的

- 数据库自增ID

  使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用

- UUID

### 2019年公司系统发布流程

1.统一在一个服务器上安装maven和git并且执行提前写好的脚本，内容如下：

- 使用git命令从gitlab上clone指定服务指定分支的代码
- 使用maven命令打包`mvn clean package spring-boot:repackage -DskipTests`
- 将打好的jar和Dockerfile都移动到执行的目录下
- 登录docker私服`docker login http://ip:port -u 用户名 -p 密码`
- 使用docker命令构建镜像`docker build -t 镜像名称 .`
- 使用docker命令将构建好的镜像上传到docker私服`docker push 镜像名称`
- 删除刚才构建好的镜像`docker rmi -f 镜像名称`
- 使用ssh命令登录到指定服务的服务器上，并且执行脚本`ssh root@ip /opt/app_docker/${service_name}/bin/startup_${service_name}.sh ${image}`

2.在各个微服务的服务器上执行提前写好的脚本，拉去镜像，并且启动容器，内容如下：

- 登录docker私服`docker login http://ip:port -u 用户名 -p 密码`

- 使用docker命令拉去刚才上传到私服上的镜像`docker pull 镜像名称`

- 停止对于服务的容器，`docker stop 容器名称`

- 删除停止的容器`docker rm 容器名称`

- 删除之前的镜像`docker rmi 镜像名称`

- 使用docker命令运行容器

  ```
  docker run -d -p 8080:8080 -v /opt/app_docker/service_${service}/log:/opt/app/log --name ${service} ${image} java -jar /opt/app/service-${service}-1.0.jar-d：后台运行-p：容器的端口和宿主机的端口做映射-v：容器里边的数据和宿主机做映射--name:指定启动后容器的名称${image}:具体要启动的镜像

  ```


- 使用docker logs 容器名称读取日志